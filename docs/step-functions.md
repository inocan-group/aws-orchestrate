---
sidebar: auto
---

# Serverless Step Functions

## Introduction

AWS offers us a service to create powerful orchestration of lambda functions or integration with other aws/external services. 

We can write a definition of our desired _step function_ that would be composed of multiple steps that would receive an state that can be manipulated (handled) by steps (as `Task Step`) _aka State Machine_.

As we metioned earlier _step functions_ definition is composed of __Steps__, and already mentioned one above (__Task Step__), which is the most common used step because it let us call an aws service as _AWS Lambda function_. There are others Step Types as conditional, map/parallel, and terminal steps like `Fail` or `Success`. 

The intent of this `module` is to give users and strongly typed and friendly API that let define step functions with more `confidence` and integrate smoothly with other `aws-orchestrate` functionalities as passing, correlation id, ssm secrets, etc.

## Preparation

TODO ...

## Usage

### Step Function Definition:

* First we need to define our state typing that should extend `IStepFunctionOrchestratedRequest` if we want to be able to pass context within headers trhough the workflow. 

```typescript
import { StepFunction } from 'aws-orchestrate'


const myStepFunction = StepFunction("myStepFunctionName").success()
```

* __Task:__ Call lambda functions or other Aws Service defined in our state machine or not.

```typescript
import { StepFunction, ITaskConfig } from 'aws-orchestrate'

/**
 *  If we want to point to a lambda function existing in our same project we can use
 *  Enum generated by `aws-orchestrated` and it will be translated to the right ARN 
 *  or just use the ARN string
 */
const myStepFunction = StepFunction<InitialState>("myStepFunctionName")
    .task(ServerlessConfigLambdaEnum.MyLambdaFunction)
    // to point to an lambda resource outside of our project we also can use ARN string
    .task("ARN string")
    // to be able to configure options as Retry, Timeout
    .task(config)
    // to define error handlers, it must be just after the task definition
    .catch("ARN string") // or config object `ITaskConfig` {}
    // we can continue the workflow after an error handled
    .task(ServerlessConfigLambdaEnum.MyLambdaFunction2)
    .success()

const config: ITaskConfig = {
    name: ServerlessConfigLambdaEnum.MyLambdaFunction, // or "ARN string"
    retry?: 1, // default 0
    timeOutSeconds?: 1000,
    end?: false // we can explicitly make this step as final step in the current scope. It's useful on `Map`Step
}
```
 
   * _Note: Keep in mind that the order of how we defined our step function is very critical because that's the order of how it will be translated to `yaml` definition._

``` mermaid
graph LR
  star("Start") --> task1[MyLambdaFunction] -- catch --> errorHandler[MyLambdaFunction Error Handler]
    task1 --> task2[MyLambdaFunction2]
    errorHandler --> task2
    task2 --> success(Success)
    
```

* __Parallel:__ provides each branch with a copy of its own input data. It generates output that is an array with one element for each branch, containing the output from that branch.

```typescript
import {StepFunction, ParallelBranch} from 'aws-orchestrate'
import {IMyStepFunctionInput} from "src/stepFunctions"

const myStepFunction = StepFunction<IMyStepFunctionInput>("myStepFunctionName")
    .task(ServerlessConfigLambdaEnum.MyLambdaFunction)
    // fan-out
    .parallel({
        input: state => state.PropToUseAsInput, // optional. default will be the entire state
        target: state => state.PropToUseAsTarget, 
        branches: [branch1, branch2]
        })
    // fan-in
    .task(ServerlessConfigLambdaEnum.MyLambdaFunction2)
    .success()

const branch1 = ParallelBranch
    .task(ServerlessConfigLambdaEnum.Branch1MyFunction1)
    .task(ServerlessConfigLambdaEnum.Branch1MyFunction2)

const branch2 = ParallelBranch
    .task(ServerlessConfigLambdaEnum.Branch2MyFunction1)
    .catch(ServerlessConfigLambdaEnum.Branch2MyFunction1ErrorHandler)
```

``` mermaid
graph LR
  star("Start") --> task1[MyLambdaFunction] --> parallel[Parallel]
    parallel .-> branch1[Branch 1]
    parallel .-> branch2[Branch 2]
    branch1 .-> b1fn1[Branch1MyFunction1]
    b1fn1 .-> b1fn2[Branch1MyFunction2]
    b1fn2 .-> task2[MyLambdaFunction2]
    branch2 .-> b2fn1[Branch2MyFunction1]
    b2fn1 -- catch .-> errorHandler[Branch2MyFunction1ErrorHandler]
    errorHandler .-> task2
    task2 --> success(Success)
```

* __Map:__ executes the same steps for multiple entries of an array in the state input.

```typescript
import {StepFunction, MapBranch} from 'aws-orchestrate'
import {IMyStepFunctionInput} from "src/stepFunctions"

const myStepFunction = StepFunction<IMyStepFunctionInput>("myStepFunctionName")
    .task(ServerlessConfigLambdaEnum.MyLambdaFunction)
    // fan-out
    .map({
        input: state => state.arrayPropInput,
        branch: myMapBranch,
        timeOutSeconds?: 1000,
        })
    // fan-in
    .task(ServerlessConfigLambdaEnum.MyLambdaFunction2)
    .success()

const myMapBranch = MapBranch
    .task(ServerlessConfigLambdaEnum.Branch1MyFunction1)
    .task(ServerlessConfigLambdaEnum.Branch1MyFunction2)

```

``` mermaid
graph LR
  star("Start") --> task1[MyLambdaFunction] --> map[Map]
    map .-> b1fn1[BranchMyFunction1]
    map .-> b2fn1[BranchMyFunction2]
    b1fn1 .-> b1fn2[BranchMyFunction2]
    b1fn2 .-> task2[MyLambdaFunction2]
    b2fn1 .-> b2fn2[BranchMyFunction2]
    b2fn2 .-> task2
    task2 --> success(Success)
```

* __

* __Wait:__ delays the state machine from continuing for a specified time.

```typescript
import {StepFunction} from 'aws-orchestrate'
import {IMyStepFunctionInput} from "src/stepFunctions"

const myStepFunction = StepFunction<IMyStepFunctionInput>("myStepFunctionName")
    .task(ServerlessConfigLambdaEnum.MyLambdaFunction)
    .wait(200) // Milliseconds 
    .success()

```

* __Success:__ stops an execution successfully.

```typescript
import {StepFunction} from 'aws-orchestrate'
import {IMyStepFunctionInput} from "src/stepFunctions"

const myStepFunction = StepFunction<IMyStepFunctionInput>("myStepFunctionName")
    .task(ServerlessConfigLambdaEnum.MyLambdaFunction)
    .success()

```

* __Fail:__ stops the execution of the state machine and marks it as a failure.

```typescript
import {StepFunction} from 'aws-orchestrate'
import {IMyStepFunctionInput} from "src/stepFunctions"

const myStepFunction = StepFunction<IMyStepFunctionInput>("myStepFunctionName")
    .task(ServerlessConfigLambdaEnum.MyLambdaFunction)
    .fail()
    // or
    .fail({
        /**
         * Provides a custom failure string that can be used for operational or diagnostic purposes.
         */
        cause: "Cause", 
        /**
         *  Provides an error name that can be used for error handling (Retry/Catch), 
         *  operational, or diagnostic purposes.
         */
        errorName: "Error Name"
    })

```
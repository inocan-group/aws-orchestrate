"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class t{constructor(){this._passthrough=!1,this._exclude=!1}static map(r){const e=new t;return e.map(r),e}static passthrough(r){const e=new t;return e.passthrough(r),e}static exclude(r){const e=new t;return e.exclude(r),e}static aggregate(r){const e=new t;return e.aggregate(r),e}get mapConfig(){return this._map}map(t){return this._map=t,this}passthrough(t){if(this._exclude){const t=new Error("You can't set both passthroughs and exclusions and exclusions are already set!");throw t.name="TypedMapper::NotAllowed",t}return this._passthrough=t,this}exclude(t){if(this._passthrough){const t=new Error("You can't set both passthroughs and exclusions and passthroughs are already set!");throw t.name="TypedMapper::NotAllowed",t}return this._exclude=t,this}input(t){return this._data=t,this}get inputData(){return this._data}convert(t){if(t&&this.input(t),!this._data){const t=new Error("You must first set the data before trying to convert!");throw t.name="TypedMapper::NotReady",t}return Array.isArray(this._data)?this._convertArray(this._data):this._convertObject(this._data)}convertArray(t){if(!t&&!Array.isArray(this._data)){const t=new Error("Using convertArray() requires that the input is also an array and it is of type "+typeof this._data);throw t.name="TypedMapper::InvalidFormat",t}return this.convert(t)}convertObject(t){if(!t&&Array.isArray(this._data)){const t=new Error("Using convertObject() requires that the input is an object and it is of type "+typeof this._data);throw t.name="TypedMapper::InvalidFormat",t}return this.convert(t)}_convertObject(t,r=[]){if(!this._map)throw new Error("Attempt convert an object failed because there was no Mapper defined yet!");const e={},s=Object.keys(this._map);for(const a of s){const s=this._map[a];e[a]="function"==typeof s?s(t,r):t[s]}if(this._passthrough){const r=Array.isArray(this._passthrough)?this._passthrough:Object.keys(t);for(const s of r)e[s]=t[s]}if(Array.isArray(this._exclude)){const r=new Set(this._exclude),s=Object.keys(t).filter((t=>!r.has(t)));for(const r of s)e[r]=t[r]}return e}_convertArray(t){const r=[];for(const e of t)r.push(this._convertObject(e));return r}aggregate(t){if(this._map){const t=new Error('A TypedMapper object should NOT have a "map" and "aggregate" configuration and this object already has a "map" configuration!');throw t.name="TypedMapper::NotAllowed",t}return this._aggregate=t,this}}var r;!function(t){t.AppError="AppError",t.LibraryError="LibraryError",t.ApiGatewayError="ApiGatewayError"}(r||(r={}));const e=function(t,e={}){class s extends Error{constructor(s,a,o={}){super(`[ ${t} ]: ${s}`),this.kind=r.LibraryError,this.library=t;const n={...e,...o};this.code=a,this.classification=`${t}/${a}`,n.errorCode&&(this.errorCode=n.errorCode)}}return s}("typed-mapper");exports.MapperError=e,exports.TypedMapper=t,exports.camelize=function(t){return t.split(/[_\s-\.]/gm).reduce(((t,r)=>""!==t?t+r.charAt(0).toUpperCase()+r.substr(1):r.charAt(0).toLowerCase()+r.substr(1)),"")},exports.dasherize=function(t){return t.split(/[_\s\.]/g).map((t=>t.charAt(0).toLowerCase()+t.substr(1).replace(/([A-Z])/gm,"-$1").toLowerCase())).join("-")},exports.pascalize=function(t){return t.split(/[_\s-\.]/gm).reduce(((t,r)=>t+r.charAt(0).toUpperCase()+r.substr(1)),"")};
